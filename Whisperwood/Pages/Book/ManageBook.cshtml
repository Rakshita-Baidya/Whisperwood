@page
@model Whisperwood.Pages.Book.BrowseModel
@{
    Layout = "_Layout";
    ViewData["Title"] = "Manage Books";
}

<div class="px-4 py-8">
    <div class="mb-4 flex justify-between">
        <h1 class="text-accent4 text-center text-4xl font-bold">Manage Books</h1>
        <div class="flex space-x-4 text-white">
            <a href="/Book/AddBook" class="bg-accent3 rounded px-4 py-2 hover:bg-accent4">Add Book</a>
            <button id="filter-button" class="bg-accent3 rounded px-4 py-2 hover:bg-accent4">Filter Books</button>
        </div>
    </div>
    <div id="filter-section" class="bg-primary border-accent3 mb-8 hidden rounded-lg border p-6 shadow-md">
        <form id="filter-form" class="grid grid-cols-1 gap-4 md:grid-cols-3 lg:grid-cols-4">
            <div>
                <label for="search" class="text-accent3 mb-1 block font-medium">Search</label>
                <input type="text" id="search" name="search" class="border-accent1 w-full rounded border p-2" placeholder="Search by title, ISBN, or synopsis" />
            </div>
            <div>
                <label for="minPrice" class="text-accent3 mb-1 block font-medium">Price Range</label>
                <div class="flex gap-2">
                    <input type="number" id="minPrice" name="minPrice" class="border-accent1 w-1/2 rounded border p-2" placeholder="Min" min="0" />
                    <input type="number" id="maxPrice" name="maxPrice" class="border-accent1 w-1/2 rounded border p-2" placeholder="Max" min="0" />
                </div>
            </div>
            <div>
                <label for="minRating" class="text-accent3 mb-1 block font-medium">Minimum Rating</label>
                <input type="number" id="minRating" name="minRating" min="0" max="5" step="0.1" class="border-accent1 w-full rounded border p-2" placeholder="0-5" />
            </div>
            <div>
                <label for="language" class="text-accent3 mb-1 block font-medium">Language</label>
                <input type="text" id="language" name="language" class="border-accent1 w-full rounded border p-2" placeholder="e.g., English" />
            </div>
            <div>
                <label for="authors" class="text-accent3 mb-1 block font-medium">Authors</label>
                <select id="authors" name="authorIds" multiple class="border-accent1 w-full rounded border p-2"></select>
            </div>
            <div>
                <label for="genres" class="text-accent3 mb-1 block font-medium">Genres</label>
                <select id="genres" name="genreIds" multiple class="border-accent1 w-full rounded border p-2"></select>
            </div>
            <div>
                <label for="publishers" class="text-accent3 mb-1 block font-medium">Publishers</label>
                <select id="publishers" name="publisherIds" multiple class="border-accent1 w-full rounded border p-2"></select>
            </div>
            <div>
                <label for="format" class="text-accent3 mb-1 block font-medium">Format</label>
                <select id="format" name="formats" multiple class="border-accent1 w-full rounded border p-2">
                    <option value="0">Paperback</option>
                    <option value="1">Hardcover</option>
                    <option value="2">Signed Edition</option>
                    <option value="3">Limited Edition</option>
                    <option value="4">First Edition</option>
                    <option value="5">Collectors Edition</option>
                    <option value="6">Authors Edition</option>
                    <option value="7">Deluxe Edition</option>
                    <option value="8">Ebook</option>
                    <option value="9">Audiobook</option>
                </select>
            </div>
            <div>
                <label for="isAvailable" class="text-accent3 mb-1 block font-medium">Availability</label>
                <select id="isAvailable" name="isAvailable" class="border-accent1 w-full rounded border p-2">
                    <option value="">All</option>
                    <option value="true">In Stock</option>
                    <option value="false">Out of Stock</option>
                </select>
            </div>
            <div>
                <label for="sortBy" class="text-accent3 mb-1 block font-medium">Sort By</label>
                <select id="sortBy" name="sortBy" class="border-accent1 w-full rounded border p-2">
                    <option value="0">Title</option>
                    <option value="1">Publication Date</option>
                    <option value="2">Price</option>
                    <option value="3">Popularity</option>
                </select>
            </div>
            <div>
                <label for="sortOrder" class="text-accent3 mb-1 block font-medium">Sort Order</label>
                <select id="sortOrder" name="sortOrder" class="border-accent1 w-full rounded border p-2">
                    <option value="0">Ascending</option>
                    <option value="1">Descending</option>
                </select>
            </div>
            <div class="flex items-end justify-end gap-2">
                <button type="submit" class="bg-accent3 rounded px-4 py-2 text-white hover:bg-accent4">Apply Filters</button>
                <button type="button" id="clear-filters" class="rounded bg-gray-500 px-4 py-2 text-white hover:bg-gray-600">Clear Filters</button>
            </div>
        </form>
    </div>

    <div id="book-list" class="hidden">
        <div class="overflow-x-auto">
            <table class="w-full text-accent2 border border-accent1 rounded-lg">
                <thead>
                    <tr class="bg-accent3 text-white">
                        <th class="p-2 text-left">Image</th>
                        <th class="p-2 text-left">Title</th>
                        <th class="p-2 text-left">Authors</th>
                        <th class="p-2 text-left">Price</th>
                        <th class="p-2 text-left">Stock</th>
                        <th class="p-2 text-center">Actions</th>
                    </tr>
                </thead>
                <tbody id="books-table-body" class="bg-white"></tbody>
            </table>
        </div>
    </div>

    <div id="no-books" class="text-accent2 mt-4 hidden text-center text-lg">No books found.</div>

    <div id="pagination-container" class="mt-6 flex justify-center gap-2"></div>
</div>

@section Scripts {
    <script>
        // configuration constants
        const page_size = 10;
        let current_page = 1;
        let all_books = [];
        let original_books = [];

        // escapes html to prevent xss
        const escape_html = (unsafe) => {
            const html_entities = {
                '&': '&amp;',
                '<': '&lt;',
                '>': '&gt;',
                '"': '&quot;',
                "'": '&#39;'
            };
            return unsafe.replace(/[&<>"']/g, match => html_entities[match]);
        };

        // validates filter inputs
        const validate_filters = (params) => {
            // validate price range (non-negative, max >= min)
            if (params.min_price && params.min_price < 0) {
                Toast.fire({
                    icon: 'error',
                    title: 'Min price cannot be negative'
                });
                return false;
            }
            if (params.max_price && params.max_price < 0) {
                Toast.fire({
                    icon: 'error',
                    title: 'Max price cannot be negative'
                });
                return false;
            }
            if (params.min_price && params.max_price && params.max_price < params.min_price) {
                Toast.fire({
                    icon: 'error',
                    title: 'Max price must be greater than or equal to min price'
                });
                return false;
            }

            // validate min rating (0-5 if provided)
            if (params.min_rating && (params.min_rating < 1 || params.min_rating > 5)) {
                Toast.fire({
                    icon: 'error',
                    title: 'Min rating must be between 1 and 5'
                });
                return false;
            }

            // validate language (alphabetic if provided)
            if (params.language && !/^[a-zA-Z\s]+$/.test(params.language)) {
                Toast.fire({
                    icon: 'error',
                    title: 'Language must contain only letters'
                });
                return false;
            }

            return true;
        };

        // fetches dropdown options for authors, genres, publishers
        const fetch_dropdown_options = async () => {
            const authors_select = document.getElementById('authors');
            const genres_select = document.getElementById('genres');
            const publishers_select = document.getElementById('publishers');

            try {
                // fetch authors
                const authors_response = await fetch('https://localhost:7018/api/Author/getall', {
                    headers: { 'Authorization': `Bearer ${window.jwtToken}` }
                });
                if (!authors_response.ok) throw new Error('Failed to load authors');
                const authors = await authors_response.json();
                authors_select.innerHTML = authors.map(a => `<option value="${a.id}">${escape_html(a.name)}</option>`).join('');

                // fetch genres
                const genres_response = await fetch('https://localhost:7018/api/Genre/getall', {
                    headers: { 'Authorization': `Bearer ${window.jwtToken}` }
                });
                if (!genres_response.ok) throw new Error('Failed to load genres');
                const genres = await genres_response.json();
                genres_select.innerHTML = genres.map(g => `<option value="${g.id}">${escape_html(g.name)}</option>`).join('');

                // fetch publishers
                const publishers_response = await fetch('https://localhost:7018/api/Publisher/getall', {
                    headers: { 'Authorization': `Bearer ${window.jwtToken}` }
                });
                if (!publishers_response.ok) throw new Error('Failed to load publishers');
                const publishers = await publishers_response.json();
                publishers_select.innerHTML = publishers.map(p => `<option value="${p.id}">${escape_html(p.name)}</option>`).join('');
            } catch (error) {
                Toast.fire({
                    icon: 'error',
                    title: error.message || 'Failed to load dropdown options'
                });
            }
        };

        // fetches all books from api
        const fetch_books = async () => {
            // check authentication
            if (!window.jwtToken) {
                Toast.fire({
                    icon: 'error',
                    title: 'please log in to view books'
                }).then(() => {
                    window.location.href = '/User/Login';
                });
                return;
            }

            try {
                const response = await fetch('https://localhost:7018/api/Book/getall', {
                    headers: { 'Authorization': `Bearer ${window.jwtToken}` }
                });

                if (response.status === 401) {
                    Toast.fire({
                        icon: 'error',
                        title: 'Please log in to view books'
                    }).then(() => {
                        window.location.href = '/User/Login';
                    });
                    return;
                }

                if (!response.ok) throw new Error('Failed to load books');

                original_books = await response.json();
                all_books = [...original_books];
                render_books(current_page);
            } catch (error) {
                Toast.fire({
                    icon: 'error',
                    title: error.message || 'Failed to load books'
                });
            }
        };

        // deletes a book by id
        const delete_book = async (book_id, book_title) => {
            // confirm deletion
            const result = await Swal.fire({
                title: `Are you sure you want to delete "${book_title}"?`,
                icon: 'warning',
                showCancelButton: true,
                confirmButtonText: 'Delete',
                cancelButtonText: 'Cancel'
            });

            if (!result.isConfirmed) return;

            // check authentication
            if (!window.jwtToken) {
                Toast.fire({
                    icon: 'error',
                    title: 'Please log in to delete books'
                }).then(() => {
                    window.location.href = '/User/Login';
                });
                return;
            }

            try {
                const response = await fetch(`https://localhost:7018/api/Book/delete/${book_id}`, {
                    method: 'DELETE',
                    headers: { 'Authorization': `Bearer ${window.jwtToken}` }
                });

                if (response.status === 401) {
                    Toast.fire({
                        icon: 'error',
                        title: 'Please log in to delete books'
                    }).then(() => {
                        window.location.href = '/User/Login';
                    });
                    return;
                }

                if (!response.ok) {
                    const error_data = await response.json();
                    throw new Error(error_data.message || 'Failed to delete book');
                }

                Toast.fire({
                    icon: 'success',
                    title: 'Book deleted successfully'
                }).then(() => {
                    fetch_books();
                });
            } catch (error) {
                Toast.fire({
                    icon: 'error',
                    title: error.message || 'Failed to delete book'
                });
            }
        };

        // renders books for the current page
        const render_books = (page) => {
            const books_table_body = document.getElementById('books-table-body');
            const no_books_element = document.getElementById('no-books');
            const pagination_container = document.getElementById('pagination-container');
            const book_list = document.getElementById('book-list');

            books_table_body.innerHTML = '';

            if (all_books.length === 0) {
                no_books_element.classList.remove('hidden');
                book_list.classList.add('hidden');
                pagination_container.innerHTML = '';
                return;
            }

            const start_index = (page - 1) * page_size;
            const end_index = Math.min(start_index + page_size, all_books.length);
            const paginated_books = all_books.slice(start_index, end_index);

            if (paginated_books.length > 0) {
                book_list.classList.remove('hidden');
                no_books_element.classList.add('hidden');

                paginated_books.forEach(book => {
                    const author_names = book.authorBooks?.length
                        ? book.authorBooks.map(ab => ab.author.name).join(', ')
                        : 'unknown author';

                    const row = document.createElement('tr');
                    row.className = 'border-b border-accent1';
                    row.innerHTML = `
                        <td class="p-2">
                            ${book.coverImage?.coverImageURL
                                ? `<img src="${escape_html(book.coverImage.coverImageURL)}" alt="${escape_html(book.title)}" class="border-2 border-accent2 h-20 w-16 object-cover" />`
                                : `<div class="text-accent3 flex h-20 w-16 items-center justify-center">no image</div>`
                            }
                        </td>
                        <td class="p-2 truncate">${escape_html(book.title)}</td>
                        <td class="p-2 truncate">${escape_html(author_names)}</td>
                        <td class="p-2">Rs. ${book.price.toFixed(2)}</td>
                        <td class="p-2">${book.stock}</td>
                        <td class="p-2">
                            <div class="flex space-x-2 justify-center">
                                <a href="/Book/Details/${book.id}" class="bg-accent3 rounded px-3 py-1 text-white hover:bg-accent4">View</a>
                                <a href="/Book/UpdateBook/${book.id}" class="bg-accent3 rounded px-3 py-1 text-white hover:bg-accent4">Update</a>
                                <button class="bg-accent3 rounded px-3 py-1 text-white hover:bg-accent4 delete-btn" data-id="${book.id}" data-title="${book.title}">Delete</button>
                            </div>
                        </td>
                    `;
                    books_table_body.appendChild(row);
                });

                const total_pages = Math.ceil(all_books.length / page_size);
                createPaginationControls('pagination-container', total_pages, page, (new_page) => {
                    current_page = new_page;
                    render_books(new_page);
                });
            } else {
                no_books_element.classList.remove('hidden');
                book_list.classList.add('hidden');
                pagination_container.innerHTML = '';
            }
        };

        // gets filter parameters from form
        const get_filter_params = () => ({
            search: document.getElementById('search').value.trim().toLowerCase(),
            min_price: parseFloat(document.getElementById('minPrice').value) || null,
            max_price: parseFloat(document.getElementById('maxPrice').value) || null,
            min_rating: parseFloat(document.getElementById('minRating').value) || null,
            language: document.getElementById('language').value.trim().toLowerCase(),
            author_ids: Array.from(document.getElementById('authors').selectedOptions).map(opt => parseInt(opt.value)),
            genre_ids: Array.from(document.getElementById('genres').selectedOptions).map(opt => parseInt(opt.value)),
            publisher_ids: Array.from(document.getElementById('publishers').selectedOptions).map(opt => parseInt(opt.value)),
            formats: Array.from(document.getElementById('format').selectedOptions).map(opt => parseInt(opt.value)),
            is_available: document.getElementById('isAvailable').value,
            sort_by: parseInt(document.getElementById('sortBy').value),
            sort_order: parseInt(document.getElementById('sortOrder').value)
        });

        // filters books based on parameters
        const filter_books = (books, params) => {
            return books
                .filter(b => {
                    // filter by search (title, isbn, synopsis)
                    if (params.search) {
                        return b.title.toLowerCase().includes(params.search) ||
                               b.isbn?.toLowerCase().includes(params.search) ||
                               b.synopsis?.toLowerCase().includes(params.search);
                    }
                    return true;
                })
                .filter(b => {
                    // filter by price range
                    if (params.min_price !== null && b.price < params.min_price) return false;
                    if (params.max_price !== null && b.price > params.max_price) return false;
                    return true;
                })
                .filter(b => {
                    // filter by min rating
                    if (params.min_rating !== null && (b.averageRating || 0) < params.min_rating) return false;
                    return true;
                })
                .filter(b => {
                    // filter by language
                    if (params.language) return b.language?.toLowerCase().includes(params.language);
                    return true;
                })
                .filter(b => {
                    // filter by authors
                    if (params.author_ids.length > 0) {
                        const book_author_ids = b.authorBooks?.map(ab => ab.author.id) || [];
                        return params.author_ids.some(id => book_author_ids.includes(id));
                    }
                    return true;
                })
                .filter(b => {
                    // filter by genres
                    if (params.genre_ids.length > 0) {
                        const book_genre_ids = b.genres?.map(g => g.id) || [];
                        return params.genre_ids.some(id => book_genre_ids.includes(id));
                    }
                    return true;
                })
                .filter(b => {
                    // filter by publishers
                    if (params.publisher_ids.length > 0) {
                        return params.publisher_ids.includes(b.publisher?.id);
                    }
                    return true;
                })
                .filter(b => {
                    // filter by format
                    if (params.formats.length > 0) return params.formats.includes(b.format);
                    return true;
                })
                .filter(b => {
                    // filter by availability
                    if (params.is_available) return b.stock > 0 === (params.is_available === 'true');
                    return true;
                })
                .sort((a, b) => {
                    // sort by selected field and order
                    const field_map = {
                        0: 'title',
                        1: 'publicationDate',
                        2: 'price',
                        3: 'popularity'
                    };
                    const field = field_map[params.sort_by];
                    const field_a = field === 'title' ? a[field].toLowerCase() :
                                    field === 'publicationDate' ? new Date(a[field]) :
                                    a[field] || 0;
                    const field_b = field === 'title' ? b[field].toLowerCase() :
                                    field === 'publicationDate' ? new Date(b[field]) :
                                    b[field] || 0;
                    const comparison = field_a > field_b ? 1 : field_a < field_b ? -1 : 0;
                    return params.sort_order === 0 ? comparison : -comparison;
                });
        };

        // clears filter form inputs
        const clear_filters = () => {
            document.getElementById('search').value = '';
            document.getElementById('minPrice').value = '';
            document.getElementById('maxPrice').value = '';
            document.getElementById('minRating').value = '';
            document.getElementById('language').value = '';
            document.getElementById('authors').selectedIndex = -1;
            document.getElementById('genres').selectedIndex = -1;
            document.getElementById('publishers').selectedIndex = -1;
            document.getElementById('format').selectedIndex = -1;
            document.getElementById('isAvailable').value = '';
            document.getElementById('sortBy').value = '0';
            document.getElementById('sortOrder').value = '0';
        };

        // initializes event listeners on dom load
        document.addEventListener('DOMContentLoaded', () => {
            // cache dom elements
            const filter_button = document.getElementById('filter-button');
            const filter_section = document.getElementById('filter-section');
            const filter_form = document.getElementById('filter-form');
            const clear_filters_button = document.getElementById('clear-filters');
            const books_table_body = document.getElementById('books-table-body');

            // toggle filter section visibility
            filter_button.addEventListener('click', () => {
                filter_section.classList.toggle('hidden');
            });

            // handle filter form submission
            filter_form.addEventListener('submit', (e) => {
                e.preventDefault();
                const params = get_filter_params();
                if (!validate_filters(params)) return;
                all_books = filter_books(original_books, params);
                current_page = 1;
                render_books(current_page);
            });

            // handle clear filters
            clear_filters_button.addEventListener('click', () => {
                clear_filters();
                all_books = [...original_books];
                current_page = 1;
                render_books(current_page);
            });

            // handle delete button clicks
            books_table_body.addEventListener('click', (e) => {
                const delete_btn = e.target.closest('.delete-btn');
                if (delete_btn) {
                    const { id, title } = delete_btn.dataset;
                    delete_book(id, title);
                }
            });

            // fetch initial data
            fetch_dropdown_options();
            fetch_books();
        });
    </script>
}